---
title: "Expected number of grandparents"
author: "Diego Alburez-Gutierrez (MPIDR);" 
date: "Nov 23 2022"
output:
  github_document:
    pandoc_args: --webtex
    toc: true
    toc_depth: 1
bibliography: kinship.bib
---

We will use matrix kinship models in a time-variant framework [@caswell_formal_2021] to compute the expected number of grandparents and grandchildren in a range of countries and the related kin dependencies. 

The code runs in R, preferably in RStudio.

<img src="DemoKin-Logo.png" align="right" width="200" />

# 1. Installation

Install the [development version](https://github.com/IvanWilli/DemoKin) of DemoKin from GitHub (could take ~1 minute). We made changes to the `DemoKin` package recently. If you had already installed the package, please uninstall it and and install it again.

```{r, eval=FALSE}
# remove.packages("DemoKin")
# install.packages("devtools")
devtools::install_github("IvanWilli/DemoKin", build_vignettes = TRUE)
```

Load packages: 

```{r, warning=F, message=FALSE}
library(DemoKin)
library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(countrycode)
library(knitr)
```

Define a function to get necessary data from the UNWPP

```{r}
get_UNWPP_inputs <- function(countries, my_startyr, my_endyr, variant = "Median"){
  
  
  print("Getting API ready...")
  # Get data from UN using API
  
  base_url <- 'https://population.un.org/dataportalapi/api/v1'
  
  # First, identify which indicator codes we want to use
  
  target <- paste0(base_url,'/indicators/?format=csv')
  codes <- read.csv(target, sep='|', skip=1) 
  
  qx_code <- codes$Id[codes$ShortName == "qx1"]
  asfr_code <- codes$Id[codes$ShortName == "ASFR1"]
  pop_code <- codes$Id[codes$ShortName == "PopByAge1AndSex"]
  
  # Get location codes
  
  target <- paste0(base_url, '/locations?sort=id&format=csv')
  df_locations <- read.csv(target, sep='|', skip=1)
  
  # find the codes for countries
  
  my_location <- 
    df_locations %>% 
    filter( Name %in% countries) %>% 
    pull(Id) %>% 
    paste(collapse = ",")
  
  # Get px values
  
  print(paste0("Getting mortality data for ", paste(countries, collapse = ", ")))
  
  my_indicator <- qx_code
  my_location  <- my_location
  
  target <- paste0(base_url,
                   '/data/indicators/',my_indicator,
                   '/locations/',my_location,
                   '/start/',my_startyr,
                   '/end/',my_endyr,
                   '/?format=csv')
  
  px <- 
    read.csv(target, sep='|', skip=1) %>% 
    filter(Variant %in% variant) %>% 
    filter(Sex == "Female") %>% 
    mutate(px = 1- Value) %>% 
    select(Location, Time = TimeLabel, age = AgeStart, px)
  
  # ASFR
  
  print(paste0("Getting fertility data for ", paste(countries, collapse = ", ")))
  
  my_indicator <- asfr_code
  
  target <- paste0(base_url,
                   '/data/indicators/',my_indicator,
                   '/locations/',my_location,
                   '/start/',my_startyr,
                   '/end/',my_endyr,
                   '/?format=csv')
  
  asfr <- 
    read.csv(target, sep='|', skip=1) %>% 
    filter(Variant %in% variant) %>% 
    select(Location, Time = TimeLabel, age = AgeStart, ASFR = Value)
  
  data <- 
    px %>% 
    left_join(asfr, by = c("Location", "Time", "age")) %>% 
    mutate(ASFR = replace(ASFR,is.na(ASFR),0)) 
  
  data
}

# To get UN population
get_unwpp_pop <- function(countries,  my_startyr = 2022, my_endyr = 2022){
  base_url <- 'https://population.un.org/dataportalapi/api/v1'
  
  # First, identify which indicator codes we want to use
  
  target <- paste0(base_url,'/indicators/?format=csv')
  codes <- read.csv(target, sep='|', skip=1) 
  
  pop_code <- codes$Id[codes$ShortName == "PopByAge1AndSex"]
  
  # Get location codes
  
  target <- paste0(base_url, '/locations?sort=id&format=csv')
  df_locations <- read.csv(target, sep='|', skip=1)
  
  # find the codes for countries
  iso3 <- countrycode(countries, origin = "country.name", destination = "iso3c")
  
  locs <- 
    df_locations %>% 
    filter(Iso3 %in% iso3) %>% 
    pull(Id) 
  
  my_location <- paste(locs, collapse = ",")
  
  print(paste0("Getting pop data for ", paste(countries, collapse = ", ")))
  
  
  # Avoid overwhelming UN APi
  if(length(countries) <= 20){
    
    my_indicator <- pop_code
    my_location  <- my_location
    
    target <- paste0(base_url,
                     '/data/indicators/',my_indicator,
                     '/locations/',my_location,
                     '/start/',my_startyr,
                     '/end/',my_endyr,
                     '/?format=csv')
    
    pop <- 
      read.csv(target, sep='|', skip=1) %>% 
      filter(Variant == "Median") %>% 
      select(iso3 = Iso3, country = Location, year = TimeLabel, age = AgeStart, sex = Sex, value = Value)
    
  } else{
    print("Many countries, I'll process in batch")
    
    my_indicator <- pop_code
    
    times <- floor(length(locs)/10)
    sp_vec <- rep(1:10, times)
    extras <- length(locs) - length(sp_vec)
    if(extras > 0) sp_vec <- c(sp_vec, 1:extras)
    
    my_location_l  <- split(locs, sp_vec)
    
    pop <- 
      lapply(1:length(my_location_l), function(n, my_location_l){
        
        print(paste0("Processing batch ", n, "/", length(my_location_l) ))
        
        loc_n <- paste(my_location_l[[n]], collapse = ",")
        
        target <- paste0(base_url,
                         '/data/indicators/',my_indicator,
                         '/locations/', loc_n,
                         '/start/',my_startyr,
                         '/end/',my_endyr,
                         '/?format=csv')
        
        pop <- read.csv(target, sep='|', skip=1)
        
        Sys.sleep(1)
        pop
      }, my_location_l) %>% 
      bind_rows() %>% 
      filter(Variant == "Median") %>% 
      select(iso3 = Iso3, country = Location, year = TimeLabel, age = AgeStart, sex = Sex, value = Value)
    
  }
  
  return(pop) 
  
}


```

# 2. Number of kin

Let's get the numbers of China, Guatemala, and Germany:

```{r}

# pick countries
countries <- c("China", "Guatemala", "Germany")

# Year range

my_startyr   <- 1950
my_endyr     <- 2022

data <- get_UNWPP_inputs(
  countries = countries
  , my_startyr = my_startyr
  , my_endyr = my_endyr
  )

```

Run kinship models for 2022 period:

```{r}

period_kin_temp <- 
  data %>%
  split(list(.$Location)) %>%
  map_df(function(X){
    print(unique(X$Location))
    U <-
      X %>%
      select(Time, age, px) %>%
      pivot_wider(names_from = Time, values_from = px) %>%
      select(-age) %>% 
      as.matrix()
    f <- X %>%
      select(Time, age, ASFR) %>%
      mutate(ASFR = ASFR/1000) %>% 
      pivot_wider(names_from = Time, values_from = ASFR) %>%
      select(-age) %>% 
      as.matrix()
    kin(U, f, time_invariant = FALSE, output_kin = c("gm","gd"), output_period = 2022)$kin_summary %>%
      mutate(Location = unique(X$Location),  .before = 1)
  })


```

 The model is for female populations along matrilineal lines, but following Caswel [-@caswell_formal_2022], we can use Keyfitz factors to multiply kin and obtain male and female kin accordingly. This is a good-enough approximation:

```{r}

period_kin <- 
  period_kin_temp %>% 
  select(Location, kin, year, age_focal, count_living) %>% 
  mutate(
    count_living = count_living*4
    , kin = ifelse(kin == "gm", "grandparents", "grandchildren"))

```

# 3. Average number of granpdarent/grandchildren

Now we can visualise the expected number of grandchildren and grandparents for an average member of the population surviving to each age. For example, a Chinese woman aged 50 has on average, 0.72 grandchildren and 0.08 living grandparents. Visually:

```{r}
period_kin %>% 
  ggplot(aes(x = age_focal, y = count_living, color = Location)) +
  geom_line(size = 2) + 
  scale_x_continuous("Age of Focal (average member of the population)") +
  scale_y_continuous("Average number of kin in 2022") +
  facet_grid(~kin) + 
  theme_bw() +
  theme(legend.position = "bottom")
```

As a table:

```{r}
period_kin %>% 
  mutate(count_living = round(count_living, 2)) %>% 
  pivot_wider(names_from = kin, values_from = count_living) %>% 
  select(-year) %>% 
  kable()
```

# 4. Age differences between grandparents and granchildren

We can plot the age difference between members of the population and their grandparents and grandchildren, in this case for 2022, but it's also possible to look at other years. 

```{r}
age_diff <- 
  period_kin_temp %>% 
  group_by(Location, year, kin) %>%
  mutate(age_diff = age_focal - mean_age) %>% 
  ungroup() %>% 
  select(Location, age_focal, kin, age_diff)

age_diff %>% 
  rename_kin() %>% 
  ggplot(aes(x = age_focal, y = age_diff, colour = Location)) +
  geom_line() +
  scale_y_continuous("Age difference between Focal and kin in 2022") +
  facet_grid(~kin) +
  theme_bw()

```

# 5. Number of grandparentes in a population 

The intuition here is that if Focal has 2 maternal grandmothers (since we are operating in a female matrilineal population). So, if we use GKP factors, we can approximate the number of grandparents as `g(x) = gm(x)*4`.  [@caswell_formal_2022]. In a given population, around 4 people will share a grandparent. So, an approximation of the number of grandparents would be a factor of the population `p(x)` by `g(x)/4`.

```{r}

# Get UN population
# World population in 2022
pop <- 
  get_unwpp_pop(countries, my_startyr = 2022, my_endyr = 2022) %>% 
  filter(sex == "Both sexes") %>%
  # filter(sex == "Female") %>%
  rename(pop_un = value)

num_gp <- 
  period_kin %>% 
  filter(kin == "grandparents") %>% 
  rename(age = age_focal) %>% 
  mutate(iso3 = countrycode(Location, origin = "country.name", destination = "iso3c")) %>% 
  pivot_wider(names_from = kin, values_from = count_living) %>% 
  left_join(pop, by = c("iso3", "year", "age")) %>% 
  mutate(
    # pop_gp = pop_un*(grandparents/grandchildren)
    number_grandparents = pop_un*grandparents/4
    , number_grandparents = ifelse(is.infinite(number_grandparents), 0, number_grandparents)
    , share_grandparents = number_grandparents/pop_un
    ) 
  # select(iso3, year, age, pop_un, number_grandparents, share_grandparents)

# Sum over all ages 

num_gp_sum <- 
  num_gp %>% 
  group_by(iso3, year) %>%
  summarise(
    number_grandparents = sum(number_grandparents)
    , pop_un = sum(pop_un)
  ) %>%
  ungroup() %>%
  mutate(share_grandparents = number_grandparents/pop_un) %>%
  select(iso3, year, number_grandparents, share_grandparents, pop_un)

num_gp_sum %>% 
  pivot_longer(number_grandparents:share_grandparents) %>% 
  ggplot(aes(y = iso3, x = value)) +
  geom_col(position = position_dodge()) +
  facet_wrap(~name, scale = "free") +
  theme_bw() +
  theme(legend.position = "bottom") +
  theme(axis.text.y = element_text(angle = 30))

```

Print

```{r}
print(num_gp_sum)
```

Quality check: plot against number of 65+

```{r}
pop_65 <- 
  pop %>% 
  filter(age >= 65) %>% 
  group_by(iso3, year) %>% 
  summarise(pop_un = sum(pop_un)) %>% 
  ungroup()

num_gp_sum %>% 
  select(iso3, year, number_grandparents) %>% 
  left_join(pop_65, by = c("iso3", "year")) %>% 
  ggplot(aes(x = number_grandparents, y = pop_un, group = iso3)) +
  geom_point() +
  geom_label(aes(label = iso3)) +
  geom_abline(slope = 1) +
  scale_x_log10("Number of grandparents") +
  scale_y_log10("Number of 65+") +
  coord_equal() +
  theme_bw()
```

While this sort of makes sense, the values are considerably higher than what we would get if we use simulations. 

# References